
{
  method asyncRisk( n ) {
    defer {
      ; -1<| 'async defer cleanup #' ++ n
    }

    ; -1<| 'async throwing #' ++ n
    throw Exception( '!AsyncFailure#' ++ n, n=n )

    ; -1<| 'not a chance to see this'
  }

  {
    # note the thrown exception will first go into `range()` which is the
    # generator being looped against, and as `range()` won't catch any
    # exception, it'll then be propagate to the for loop here
    for i from range( 3 ) do go asyncRisk( i )

    throw Exception( '!SyncFailure' )
  } @=> { # this finally block will only run by the thread
    # installed it, i.e. the forker thread
    { exc } -> { # forker's finally block only knows about sync
      # exceptions
      ; -1<| 'forker cleanup with a failure: ' ++ desc( exc )
    }
    ; -1<| 'forker cleanup without failure'
  } $=> {@ # use a scoped block for the catch, as this catch block can run
    # in any descendant thread, it's race condation to capture the thrown
    # exception as a named attribute into a shared scope then use it along.

    # a scoped block always creates a new scope on evaluation, so every
    # exception is handled in a thread-local scope, then we are safe wrt
    # concurrency

    { exc } -> { # this exception handler will be triggered
      # to run in multiple forked threads (forkees), as well as in
      # the forker thread. but its recover continuation will only
      # run by the thread installed it, i.e. the forker thread.
      ; -1<| 'handling ' ++ exc
    }
  @}

  # too obviously, but it could really go wrong with,
  # a continuation based implementation
  ; -1<| 'this should run only once by forker thread'

  for _ from console.everyMillis( 10 ) do break

  ; -1<| 'all done.'
}


# Note:
# we use negative log level to trigger debug trace, so thread
# id is shown as well;
# and the minus sign (-) will parse as infix subtraction
# operator if following some expression, so we prefix it with
# a semicolon (;) to disambiguate;
# then `;-1<| 'xxx'` reads `trace "xxx"` with extra info
